# Backend Test Task

Полная постановка задания находится в [TASK.md](./TASK.md).

## Быстрый старт

```bash
docker compose up --build
```

API: `http://localhost:3000`

## Полезные команды

```bash
docker compose exec api npm run migrate
docker compose exec api npm test
docker compose down -v
```

## Что сдавать

- ссылка на репозиторий или ветку с изменениями;
- обновленный `README.md` с разделом `Анализ и рефакторинг` (ответы на 7 вопросов из `TASK.md`);
- инструкция запуска тестов и подтверждение, что обязательные сценарии проходят.

## Анализ и рефакторинг
1. Какие проблемы были в исходной реализации списания?
Отсутсвие проверки идентификатора запроса, в методе `getUserBalance` также получали `expired accrual` и отсутствие транзакции БД.

2. Какие проблемы при одновременных запросах вы устранили и как именно?
Чтобы одновременные запросы не могли увести баланс бонусов в минус, в методе `getUserBalance` происходит вычет суммы списаний из суммы всех начислений (кроме `expired accrual`). Также была добавлена транзакция с блокировкой обновления для предотвращения `race condition`.

3. Какие обязательные правила корректности вы обеспечили на уровне БД и на уровне кода?
Добавлена миграция, удаляющая `bonus_transactions_request_id_uq`, c новым индексом, чтобы на уровне бд не позволять создавать одинаковый `spend`, которые не входят в область идемпотентности `(user_id, requestId)`. Дополнительно в коде:
- происходит проверка, что нету идентичного списания по `user_id` и `requestId`;
- происходит поиск дубликата списания (с одинаковым `amount` и `user_id`, но не идентичным `request_id`);
- проверка, что в запросе есть загаловок `Idempotency-Key` или в теле запроса есть поле `requestId`;

4. Как реализована защита от повторного одинакового запроса (`duplicate request`)?
В методе `spendUserBonus` происходит проверка, то в запросе есть загаловок `Idempotency-Key` или в теле запроса есть поле `requestId`. В методе `spendUserBonus` происходит запрос в бд, где ищем транзакцию с идентичным `user_id` и `request_id`.

5. Как обеспечено, что просроченное начисление (`expired accrual`) не участвует в балансе?
В методе `getUserBonusTransactions` при получение начислений добавлена проверка `expires_at >= сегодняшней даты и времени`.

6. Как реализована надежная обработка очереди (повторные попытки, паузы, защита от дублей)?
В методе `enqueueExpireAccrualsJob`, когда происходит создание `Job` передаются параметры: `jobId: "expire-accruals"` (для предотвращения дублирования), `attempts: 3` (повторные попытки), `backoff: { type: "exponential", delay: 1000, }` (паузы).

7. Какие компромиссы вы приняли в рамках ограничения `4–6 часов`?
- Использование отдельных запрос в бд на проверку дублирующихся транзакций, чтобы возвращать ответ `{ "success": true, "duplicated": true }` корректно;
- Написание отдельной функции `expireAccruals` для работы с данными;
